#!/usr/bin/env bash

set -o errexit
set -o errtrace
set -o pipefail

PACKAGE=$(basename "${BASH_SOURCE[0]}")

FORCE_SETUP_IF_EXISTS=0
BROADCAST_MAC='00:00:00:00:00:00'
CHECK_CONFIG=0
EXECUTE_AFTER_DEPLOY=1
RET_VAL=0

# RET_VAL:
# - 0: installed
# - 1: skip
# - 2: vnid occupied
# - 3: dev config out-of-date
function SetUpVxLAN() {
    PARENT_DEV=$1
    VXLAN_DEV=$2
    VNID=$3
    UDP_PORT=$4
    RET_VAL=0

    LINK_CHECK=$(ip link)

    if [ -z "${LINK_CHECK##*$VXLAN_DEV:*}" ]; then
        if [ $FORCE_SETUP_IF_EXISTS -eq 0 ]; then
            LINK_CHECK=$(ip -d link show type vxlan)

            # check if $VXLAN_DEV is a vxlan device
            if [ -n "${LINK_CHECK##*$VXLAN_DEV:*}" ]; then
                RET_VAL=3
                # echo "dev type changed"
                return 0
            fi

            LINK_CHECK=$(ip -d link show dev "$VXLAN_DEV" | grep vxlan)

            # check if vnid of $VXLAN_DEV has changed
            VNID_CHECK="id $VNID"

            if [ -n "${LINK_CHECK##*$VNID_CHECK*}" ]; then
                RET_VAL=3
                # echo "vnid changed"
                return 0
            fi

            # check if udp port of $VXLAN_DEV has changed
            PORT_CHECK="dstport $UDP_PORT"

            if [ -n "${LINK_CHECK##*$PORT_CHECK*}" ]; then
                RET_VAL=3
                # echo "port changed"
                return 0
            fi

            # pass all check, skip it
            RET_VAL=1
            return 0
        fi
        sudo ip link del "$VXLAN_DEV"
    fi

    LINK_CHECK=$(ip -d link show type vxlan)

    if [ -n "$LINK_CHECK" ]; then
        OTHER_VXLAN_CFG=$(echo "$LINK_CHECK" | grep vxlan)

        VNID_CHECK="id $VNID"

        if [ -z "${OTHER_VXLAN_CFG##*$VNID_CHECK*}" ]; then
            RET_VAL=2
            return 0
        fi
    fi

    #LINK_CFG='link.cfg'
    #ip link > $LINK_CFG

    #if grep -q "$VXLAN_DEV" "$LINK_CFG"; then
    #    if [ $FORCE_SETUP_IF_EXISTS -eq 0 ]; then
    #        rm -f $LINK_CFG
    #        RET_VAL=1
    #        return 0
    #    fi
    #    sudo ip link del "$VXLAN_DEV"
    #fi

    sudo ip link add link "$PARENT_DEV" name "$VXLAN_DEV" type vxlan id "$VNID" dstport "$UDP_PORT" learning
    sudo ip link set "$VXLAN_DEV" up

    #rm -f $LINK_CFG
}

function DelVxLan() {
    VXLAN_DEV=$1

    LINK_CHECK=$(ip link)

    if [ -z "${LINK_CHECK##*$VXLAN_DEV:*}" ]; then
        sudo ip link del "$VXLAN_DEV"
    fi
}

function EnableForwarding() {
    sudo iptables -P FORWARD ACCEPT
}

function AssignIP() {
    VXLAN_DEV=$1
    IP=$2
    RET_VAL=0

    #ADDR_CFG='addr.cfg'
    #ip addr show dev "$VXLAN_DEV" > $ADDR_CFG

    ADDR_CHECK=$(ip addr show dev "$VXLAN_DEV")

    if [ -z "${ADDR_CHECK##*$IP*}" ]; then
        RET_VAL=1
    else
        sudo ip addr add "$IP" dev "$VXLAN_DEV"
    fi

    #if grep -q "$IP" "$ADDR_CFG"; then
    #    RET_VAL=1
    #else
    #    sudo ip addr add "$IP" dev "$VXLAN_DEV"
    #fi

    #rm -f $ADDR_CFG
}

function AppendNewFDBEntry() {
    VXLAN_DEV=$1
    REMOTE_IP=$2
    RET_VAL=0

    #FDB_CFG='fdb.cfg'
    #bridge fdb show > $FDB_CFG

    FDB_CHECK=$(bridge fdb show)
    TOKEN="dev $VXLAN_DEV dst $REMOTE_IP"

    if [ -z "${FDB_CHECK##*$TOKEN*}" ]; then
        RET_VAL=1
    else
        sudo bridge fdb append "$BROADCAST_MAC" dev "$VXLAN_DEV" dst "$REMOTE_IP" self permanent
    fi

    #if grep -q "dev $VXLAN_DEV dst $REMOTE_IP" "$FDB_CFG"; then
    #    RET_VAL=1
    #else
    #    bridge fdb append "$BROADCAST_MAC" dev "$VXLAN_DEV" dst "$REMOTE_IP" self permanent
    #fi

    #rm -f $FDB_CFG
}

function RouteCidr() {
    DEV=$1
    XCIDR=$2
    VIA_IP=$3
    RET_VAL=0

    ROUTE_CHECK=$(ip route show dev "$DEV")

    if [ -z "${ROUTE_CHECK##*$XCIDR*}" ]; then
        RET_VAL=1
    else
        if [ -z "$VIA_IP" ]; then
            sudo ip route add "$XCIDR" dev "$DEV"
        else
            sudo ip route add "$XCIDR" dev "$DEV" via "$VIA_IP" onlink
        fi
    fi
}

REQUEST_VXLAN_DEV=''
REQUEST_PARENT_DEV=''
REQUEST_VNID=''
REQUEST_CIDR=''
REQUEST_PORT=''
REQUEST_NODES=()
REQUEST_IPS=()
REQUEST_GATEWAY_NODE=''

function ReadParamFromFlags() {
    REQUEST_VXLAN_DEV='eth1'
    REQUEST_PARENT_DEV='eth0'
    REQUEST_VNID=100
    REQUEST_PORT=4096

    while test $# -gt 0; do
      case "$1" in
          -h|--help)
            echo "parameters:"
            echo "-h, --help                   show brief help"
            echo "--cidr=CIDR                  specify the cidr of the underlay network, omit if empty"
            echo "--underlay-dev=DEV_NAME      designate a name for the device on underlay network, default as $REQUEST_VXLAN_DEV"
            echo "--parent-dev=DEV_NAME        specify the parent device from which underlay device is derived, default as $REQUEST_PARENT_DEV"
            echo "--net-id=ID                  specify the vnid for vxlan tunnel for underlay traffic, default as $REQUEST_VNID"
            echo "--udp-port=PORT              specify the udp port of vxlan tunnel for underlay traffic, default as $REQUEST_PORT"
            exit 0
            ;;
          --cidr*)
            REQUEST_CIDR=`echo $1 | sed -e 's/^[^=]*=//g'`
            shift
            ;;
          --underlay-dev*)
            REQUEST_VXLAN_DEV=`echo $1 | sed -e 's/^[^=]*=//g'`
            shift
            ;;
          --parent-dev*)
            REQUEST_PARENT_DEV=`echo $1 | sed -e 's/^[^=]*=//g'`
            shift
            ;;
          --net-id*)
            REQUEST_VNID=`echo $1 | sed -e 's/^[^=]*=//g'`
            shift
            ;;
          --udp-port*)
            REQUEST_PORT=`echo $1 | sed -e 's/^[^=]*=//g'`
            shift
            ;;
          *)
            break
            ;;
      esac
    done

    REQUEST_NODES=()

    while test $# -gt 0; do
        REQUEST_NODES+=("$1")
        shift
    done

    if [ -z "$REQUEST_CIDR" ]; then
        echo "no cidr found, stop underlay ip auto assignment"
        return 0
    fi

    NET=$(echo "$REQUEST_CIDR" | awk '{split($0,a,"/"); print a[1]}')
    RANGE=$(echo "$REQUEST_CIDR" | awk '{split($0,a,"/"); print a[2]}')

    if [ -z "$RANGE" ]; then
        RANGE=24
    fi

    if [[ $RANGE -gt 24 ]]; then
        echo "currently not support cidr $REQUEST_CIDR"
        return 1
    fi

    for (( i = 0; i < ${#REQUEST_NODES[@]}; i++ )); do
        NODE=${REQUEST_NODES[$i]}
        IP="$(echo "$NET" | awk '{split($0,a,"\."); print a[1]}' 2>/dev/null).$(echo "$NET" | awk '{split($0,a,"\."); print a[2]}' 2>/dev/null).$(echo "$NET" | awk '{split($0,a,"\."); print a[3]}' 2>/dev/null)"
        HOST=$((i+1))
        IP="$IP.$HOST/$RANGE"
        REQUEST_IPS[$i]=$IP
    done
}

function ExtractParamFromYaml() {
    CONFIG=$1

    REQUEST_VXLAN_DEV=$(grep "dev" "$CONFIG" 2>/dev/null | awk '{print $2}')
    REQUEST_PARENT_DEV=$(grep "parent" "$CONFIG" 2>/dev/null | awk '{print $2}')
    REQUEST_VNID=$(grep "vnid" "$CONFIG" 2>/dev/null | awk '{print $2}')
    REQUEST_CIDR=$(grep "cidr" "$CONFIG" 2>/dev/null | awk '{print $2}')
    REQUEST_PORT=$(grep "port" "$CONFIG" 2>/dev/null | awk '{print $2}')

    REQUEST_NODES=()
    REQUEST_IPS=()
    REQUEST_GATEWAY_NODE=""

    RANGE=$(echo "$REQUEST_CIDR" | awk '{split($0,a,"/"); print a[2]}')
    if [ -z "$RANGE" ]; then
        RANGE=24
    fi

    NODES_START_FROM=$(awk '/nodes:/{print NR}' "$CONFIG")
    NODES_CFG="$(awk "NR>$NODES_START_FROM" "$CONFIG")"

    declare -i idx=-1

    while read -r config || [ -n "$config" ]
    do
        if [ -z "$config" ]; then
            continue
        fi

        if [[ $config == -* ]]; then
            idx+=1
            config=${config#"-"}
        fi

        key=$(echo "$config" | awk '{print $1}')
        key=${key%":"}
        val=$(echo "$config" | awk '{print $2}')

        case $key in
        node)
          REQUEST_NODES[$idx]=$val
          ;;
        ip)
          if [ -z "$(echo "$val" | awk '{split($0,a,"/"); print a[2]}')" ]; then
              val="$val/$RANGE"
          fi
          REQUEST_IPS[$idx]=$val
          ;;
        gateway)
          if [ "$val" == "true" ]; then
              REQUEST_GATEWAY_NODE=$idx
          fi
          ;;
        esac
    done <<< "$NODES_CFG"

    #REQUEST_GATEWAY_NODE=${REQUEST_NODES[$REQUEST_GATEWAY_NODE]}
}

function LiteConfigRequestNetwork() {
    SETUP="sudo ip link add link $REQUEST_PARENT_DEV name $REQUEST_VXLAN_DEV type vxlan id $REQUEST_VNID dstport $REQUEST_PORT learning && sudo ip link set $REQUEST_VXLAN_DEV up && sudo iptables -P FORWARD ACCEPT"
    FDB=''
    for (( i = 0; i < ${#REQUEST_NODES[@]}; i++ )); do
        NODE=${REQUEST_NODES[$i]}
        FDB="$FDB && sudo bridge fdb append $BROADCAST_MAC dev $REQUEST_VXLAN_DEV dst $NODE self permanent"
    done

    for (( i = 0; i < ${#REQUEST_NODES[@]}; i++ )); do
        NODE=${REQUEST_NODES[$i]}
        IP=${REQUEST_IPS[$i]}

        echo "[$i] calling slave on $NODE:"
        if [ -n "$IP" ]; then
            REMOTE_CALL="$SETUP && sudo ip addr add $IP dev $REQUEST_VXLAN_DEV $FDB"
        else
            REMOTE_CALL="$SETUP $FDB"
        fi

        # echo "$REMOTE_CALL"
        ssh -t root@"$NODE" "$REMOTE_CALL"
    done
}

function ConfigRequestNetwork() {
    if [ $CHECK_CONFIG -ne 0 ]; then
        echo "[$REQUEST_CIDR] [dev=$REQUEST_VXLAN_DEV, parent=$REQUEST_PARENT_DEV, vnid=$REQUEST_VNID, port=$REQUEST_PORT]"
        for (( i = 0; i < ${#REQUEST_NODES[@]}; i++ )); do
            NODE=${REQUEST_NODES[$i]}
            IP=${REQUEST_IPS[$i]}
            IS_GATEWAY='no'
            if [ "$NODE" == "$REQUEST_GATEWAY_NODE" ]; then
                IS_GATEWAY='yes'
            fi
            echo "[$i] [node=$NODE, ip=$IP, is-gateway=$IS_GATEWAY]"
        done

        read -r -n1 -p "Proceed[y/n]: " proceed
        echo ""
        if [ "$proceed" != "y" ]; then
            echo "quit this underlay network config"
            return 1
        fi
    fi

    SLAVE_CLIENT="$PACKAGE-slave"
    cp "$PACKAGE" "$SLAVE_CLIENT"
    SLAVE_SET=""

    for (( i = 0; i < ${#REQUEST_NODES[@]}; i++ )); do
        NODE=${REQUEST_NODES[$i]}
        SLAVE_SET="$SLAVE_SET $NODE"
        scp $SLAVE_CLIENT root@"$NODE":. > /dev/null
    done

    echo "all slave client sent!"

    if [ $EXECUTE_AFTER_DEPLOY -ne 1 ]; then
        echo "quit execute slave"
        return 0
    fi

    for (( i = 0; i < ${#REQUEST_NODES[@]}; i++ )); do
        SLAVE_ARGS="--underlay-dev=$REQUEST_VXLAN_DEV --parent-dev=$REQUEST_PARENT_DEV --net-id=$REQUEST_VNID --udp-port=$REQUEST_PORT"

        if [ $FORCE_SETUP_IF_EXISTS -ne 0 ]; then
            SLAVE_ARGS="$SLAVE_ARGS --force"
        fi

        NODE=${REQUEST_NODES[$i]}
        IP=${REQUEST_IPS[$i]}

        if [ -n "$IP" ]; then
            SLAVE_ARGS="$SLAVE_ARGS --local-underlay-ip=$IP"
        fi

        #if [ "$NODE" == "$REQUEST_GATEWAY_NODE" ]; then
        #    SLAVE_ARGS="$SLAVE_ARGS --as-gateway=$CIDR"
        #fi

        SLAVE_ARGS="$SLAVE_ARGS $SLAVE_SET"

        echo "[$i] calling slave on $NODE:"
        REMOTE_CALL="./$SLAVE_CLIENT slave $SLAVE_ARGS"
        # echo "$REMOTE_CALL"
        ssh -t root@"$NODE" "$REMOTE_CALL"
    done
}

function ssh-auth() {
    while test $# -gt 0; do
      case "$1" in
          -h|--help)
          echo "$PACKAGE-ssh-auth - ssh without type password each time"
          echo " "
          echo "$PACKAGE ssh-auth [options] [nodes]"
          echo " "
          echo "options:"
          echo "-h, --help                show brief help"
          exit 0
          ;;
        *)
          break
          ;;
      esac
    done

    ssh-keygen

    while test $# -gt 0; do
      IP=$1
      echo "copy ssh key to $IP"
      ssh-copy-id root@"$IP"
      shift
    done
}

function master() {
    while test $# -gt 0; do
      case "$1" in
          -h|--help)
          echo "$PACKAGE-master - master client for underlay mocker using vxlan tunnel"
          echo " "
          echo "$PACKAGE master [options] using [files]"
          echo "$PACKAGE master [options] auto [parameters] [nodes]"
          echo " "
          echo "options:"
          echo "-h, --help                   show brief help"
          echo "--check-config               display underlay network config and decide whether to proceed"
          echo "--force                      force to set up an underlay device even if it already exists"
          echo "--no-execute-slave           do not execute slave client after the deployment"
          exit 0
          ;;
        --check-config)
          CHECK_CONFIG=1
          shift
          ;;
        --force)
          FORCE_SETUP_IF_EXISTS=1
          shift
          ;;
        --no-execute-slave)
          EXECUTE_AFTER_DEPLOY=0
          shift
          ;;
        *)
          break
          ;;
      esac
    done

    LOAD_STYLE=$1
    shift

    case $LOAD_STYLE in
    using)
      while test $# -gt 0; do
          CONFIG=$1
          if [ ! -f "$CONFIG" ]; then
              echo "file not exists: $CONFIG"
              exit 1
          fi
          ExtractParamFromYaml "$CONFIG"
          ConfigRequestNetwork
          echo "$CONFIG configured!"
          shift
      done
      ;;
    auto)
       while test $# -gt 0; do
        case "$1" in
            -h|--help)
              echo "$PACKAGE-master-auto - auto-configured master client for underlay mocker using vxlan tunnel"
              echo " "
              echo "$PACKAGE master auto [parameters] [nodes]"
              echo "$PACKAGE master --force auto [parameters] [nodes]"
              echo " "
              break
              ;;
            *)
              break
              ;;
        esac
      done
      ReadParamFromFlags "$@"
      ConfigRequestNetwork
      echo "auto underlay network configured!"
      ;;
    *)
      echo "unknown operation"
      exit 1
      ;;
    esac
}

function slave() {
    VXLAN_DEV=""
    PARENT_DEV=""
    VNID=""
    PORT=""
    UNDERLAY_IP=""
    AS_GATEWAY=""

    while test $# -gt 0; do
      case "$1" in
          -h|--help)
          echo "$PACKAGE-slave - slave client for underlay mocker using vxlan tunnel"
          echo " "
          echo "$PACKAGE slave [options] [nodes]"
          echo " "
          echo "options:"
          echo "-h, --help                   show brief help"
          echo "--local-underlay-ip=IP       set an underlay network ip for this node"
          echo "--underlay-dev=DEV_NAME      designate a name for the device on underlay network"
          echo "--parent-dev=DEV_NAME        specify the parent device from which underlay device is derived"
          echo "--net-id=ID                  specify the vnid for vxlan tunnel for underlay traffic"
          echo "--udp-port=PORT              specify the udp port of vxlan tunnel for underlay traffic"
          echo "--force                      force to set up an underlay device even if it already exists"
          exit 0
          ;;
        --local-underlay-ip*)
          UNDERLAY_IP=`echo $1 | sed -e 's/^[^=]*=//g'`
          shift
          ;;
        --underlay-dev*)
          VXLAN_DEV=`echo $1 | sed -e 's/^[^=]*=//g'`
          shift
          ;;
        --parent-dev*)
          PARENT_DEV=`echo $1 | sed -e 's/^[^=]*=//g'`
          shift
          ;;
        --net-id*)
          VNID=`echo $1 | sed -e 's/^[^=]*=//g'`
          shift
          ;;
        --udp-port*)
          PORT=`echo $1 | sed -e 's/^[^=]*=//g'`
          shift
          ;;
        --force)
          FORCE_SETUP_IF_EXISTS=1
          shift
          ;;
        *)
          break
          ;;
      esac
    done

    SetUpVxLAN "$PARENT_DEV" "$VXLAN_DEV" "$VNID" "$PORT"
    EnableForwarding

    case $RET_VAL in
    0)
      echo "  [1] $VXLAN_DEV installed!"
      ;;
    1)
      echo "  [1] $VXLAN_DEV already exists, skip this step."
      ;;
    2)
      echo "  [1] vnid $VNID has been occupied, abort."
      exit 1
      ;;
    *)
      echo "  [1] config of $VXLAN_DEV has changed, try add '--force' if you insist, abort."
      exit 1
      ;;
    esac

    if [ -n "$UNDERLAY_IP" ]; then
        AssignIP "$VXLAN_DEV" "$UNDERLAY_IP"
        if [ $RET_VAL -ne 0 ]; then
            echo "  [1] $UNDERLAY_IP already assigned to $VXLAN_DEV, skip this step."
        else
            echo "  [1] Assign $UNDERLAY_IP to $VXLAN_DEV!"
        fi
    fi

    while test $# -gt 0; do
      AppendNewFDBEntry "$VXLAN_DEV" "$1"
      shift
    done

    echo "  [2] fdb on dev $VXLAN_DEV configured!"

    if [ -n "$AS_GATEWAY" ]; then
      if [ -z "$UNDERLAY_IP" ]; then
          echo "  [3] failed to work as gateway: no underlay ip assigned"
          exit 1
      fi
      echo "  [3] work as gateway node: done"
    else
      echo "  [3] work as normal node: done"
    fi
}

function lite() {
    while test $# -gt 0; do
      case "$1" in
          -h|--help)
            echo "$PACKAGE-lite - lightweight client for underlay mocker using vxlan tunnel"
            echo " "
            echo "$PACKAGE lite [parameters] [nodes]"
            echo " "
            break
            ;;
          *)
            break
            ;;
      esac
    done

    ReadParamFromFlags "$@"
    LiteConfigRequestNetwork
    echo "auto underlay network configured!"
}

function help() {
    echo "$PACKAGE - client for underlay mocker using vxlan tunnel"
    echo " "
    echo "$PACKAGE tool [-h|--help] [options] [other arguments]"
    echo " "
    echo "tools:"
    echo "ssh-auth              authenticate ssh connection towards those nodes"
    echo "master                master-client of underlay mocker, for slave deploying and config distributing"
    echo "slave                 slave-client of underlay mocker, for concrete setting"
    echo "lite                  lightweight client of underlay mocker without slave deploying"
    echo " "
    echo "How to use $PACKAGE to mock an underlay network on VPC:"
    echo "1. copy \"underlayctl\" and your underlay network config to one of your VPC nodes"
    echo "2. use tool \"ssh-auth\" to generate ssh key"
    echo "3. use tool \"master\" or \"lite\" to specify underlay network config. It will finish rest jobs."
}

if [ $# == 0 ]; then
    help
    exit 0
fi

case "$1" in
  -h|--help)
    help
    exit 0
    ;;
  ssh-auth)
    shift
    ssh-auth "$@"
    ;;
  master)
    shift
    master "$@"
    ;;
  slave)
    shift
    slave "$@"
    ;;
  lite)
    shift
    lite "$@"
    ;;
  *)
    echo "cannot recognize tool: $1"
    help
    ;;
esac

